# -*- coding: utf-8 -*-
"""Stats NLP vowel analysis

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WZHQRhg9YoV3dqx5hDvZU5PI0xyDQmOk
"""

!pip install seaborn

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import confusion_matrix, f1_score
import seaborn as sns
import matplotlib.pyplot as plt
from google.colab import drive

drive.mount('/content/drive')

# Reads my csv file and prints the first five entries in the dataframe
file_path = '/content/drive/My Drive/Stats NLP/Stat_NLP_data.csv'
df = pd.read_csv(file_path)
print(df.head())

# Splits data by gender
df_male = df[df['Gender'] == 'M']
df_female = df[df['Gender'] == 'F']

print('Done')

"""# Both genders, Euclidean distance, and k = 1 to 11"""

# Splits data with various random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Combines train and test sets for both genders
    train_set = pd.concat([train_male, train_female])
    test_set = pd.concat([test_male, test_female])

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_set['Vowel Phoneme']

    X_test = test_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_set['Vowel Phoneme']

    # Creates the k-NN classifier with k=1 and Euclidean distance metric
    knn = KNeighborsClassifier(n_neighbors=1, metric='euclidean')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Combines train and test sets for both genders
    train_set = pd.concat([train_male, train_female])
    test_set = pd.concat([test_male, test_female])

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_set['Vowel Phoneme']

    X_test = test_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_set['Vowel Phoneme']

    # Creates the k-NN classifier with k=3 and Euclidean distance metric
    knn = KNeighborsClassifier(n_neighbors=3, metric='euclidean')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Combines train and test sets for both genders
    train_set = pd.concat([train_male, train_female])
    test_set = pd.concat([test_male, test_female])

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_set['Vowel Phoneme']

    X_test = test_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_set['Vowel Phoneme']

    # Creates the k-NN classifier with k=5 and Euclidean distance metric
    knn = KNeighborsClassifier(n_neighbors=5, metric='euclidean')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Combines train and test sets for both genders
    train_set = pd.concat([train_male, train_female])
    test_set = pd.concat([test_male, test_female])

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_set['Vowel Phoneme']

    X_test = test_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_set['Vowel Phoneme']

    # Creates the k-NN classifier with k=7 and Euclidean distance metric
    knn = KNeighborsClassifier(n_neighbors=7, metric='euclidean')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Combines train and test sets for both genders
    train_set = pd.concat([train_male, train_female])
    test_set = pd.concat([test_male, test_female])

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_set['Vowel Phoneme']

    X_test = test_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_set['Vowel Phoneme']

    # Creates the k-NN classifier with k=9 and Euclidean distance metric
    knn = KNeighborsClassifier(n_neighbors=9, metric='euclidean')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Combines train and test sets for both genders
    train_set = pd.concat([train_male, train_female])
    test_set = pd.concat([test_male, test_female])

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_set['Vowel Phoneme']

    X_test = test_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_set['Vowel Phoneme']

    # Creates the k-NN classifier with k=11 and Euclidean distance metric
    knn = KNeighborsClassifier(n_neighbors=11, metric='euclidean')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

"""# Both genders, Manhattan distance, and k = 1 to 7"""

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Combines train and test sets for both genders
    train_set = pd.concat([train_male, train_female])
    test_set = pd.concat([test_male, test_female])

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_set['Vowel Phoneme']

    X_test = test_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_set['Vowel Phoneme']

    # Creates the k-NN classifier with k=1 and Manhattan distance metric
    knn = KNeighborsClassifier(n_neighbors=1, metric='manhattan')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Combines train and test sets for both genders
    train_set = pd.concat([train_male, train_female])
    test_set = pd.concat([test_male, test_female])

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_set['Vowel Phoneme']

    X_test = test_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_set['Vowel Phoneme']

    # Creates the k-NN classifier with k=3 and Manhattan distance metric
    knn = KNeighborsClassifier(n_neighbors=3, metric='manhattan')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Combines train and test sets for both genders
    train_set = pd.concat([train_male, train_female])
    test_set = pd.concat([test_male, test_female])

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_set['Vowel Phoneme']

    X_test = test_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_set['Vowel Phoneme']

    # Creates the k-NN classifier with k=5 and Manhattan distance metric
    knn = KNeighborsClassifier(n_neighbors=5, metric='manhattan')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Combines train and test sets for both genders
    train_set = pd.concat([train_male, train_female])
    test_set = pd.concat([test_male, test_female])

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_set['Vowel Phoneme']

    X_test = test_set[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_set['Vowel Phoneme']

    # Creates the k-NN classifier with k=7 and Manhattan distance metric
    knn = KNeighborsClassifier(n_neighbors=7, metric='manhattan')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

"""# Male data, Euclidean distance, and k = 1 to 7"""

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Separate features (formants) and labels (vowel phonemes)
    X_train = train_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_male['Vowel Phoneme']

    X_test = test_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_male['Vowel Phoneme']

    # Creates the k-NN classifier with k=1 and Euclidean distance metric
    knn = KNeighborsClassifier(n_neighbors=1, metric='euclidean')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Separate features (formants) and labels (vowel phonemes)
    X_train = train_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_male['Vowel Phoneme']

    X_test = test_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_male['Vowel Phoneme']

    # Creates the k-NN classifier with k=3 and Euclidean distance metric
    knn = KNeighborsClassifier(n_neighbors=3, metric='euclidean')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Separate features (formants) and labels (vowel phonemes)
    X_train = train_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_male['Vowel Phoneme']

    X_test = test_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_male['Vowel Phoneme']

    # Creates the k-NN classifier with k=5 and Euclidean distance metric
    knn = KNeighborsClassifier(n_neighbors=5, metric='euclidean')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Separate features (formants) and labels (vowel phonemes)
    X_train = train_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_male['Vowel Phoneme']

    X_test = test_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_male['Vowel Phoneme']

    # Creates the k-NN classifier with k=7 and Euclidean distance metric
    knn = KNeighborsClassifier(n_neighbors=7, metric='euclidean')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

"""# Male data, Manhattan distance, and k = 1 to 7"""

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Separate features (formants) and labels (vowel phonemes)
    X_train = train_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_male['Vowel Phoneme']

    X_test = test_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_male['Vowel Phoneme']

    # Creates the k-NN classifier with k=1 and Manhattan distance metric
    knn = KNeighborsClassifier(n_neighbors=1, metric='manhattan')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Separate features (formants) and labels (vowel phonemes)
    X_train = train_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_male['Vowel Phoneme']

    X_test = test_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_male['Vowel Phoneme']

    # Creates the k-NN classifier with k=3 and Manhattan distance metric
    knn = KNeighborsClassifier(n_neighbors=3, metric='manhattan')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Separate features (formants) and labels (vowel phonemes)
    X_train = train_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_male['Vowel Phoneme']

    X_test = test_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_male['Vowel Phoneme']

    # Creates the k-NN classifier with k=5 and Manhattan distance metric
    knn = KNeighborsClassifier(n_neighbors=5, metric='manhattan')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits male data
    train_male, test_male = split_data(df_male, random_state)

    # Separate features (formants) and labels (vowel phonemes)
    X_train = train_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_male['Vowel Phoneme']

    X_test = test_male[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_male['Vowel Phoneme']

    # Creates the k-NN classifier with k=7 and Manhattan distance metric
    knn = KNeighborsClassifier(n_neighbors=7, metric='manhattan')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

"""# Female data, Euclidean distance, k = 1 to 7"""

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_female['Vowel Phoneme']

    X_test = test_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_female['Vowel Phoneme']

    # Creates the k-NN classifier with k=1 and Euclidean distance metric
    knn = KNeighborsClassifier(n_neighbors=1, metric='euclidean')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_female['Vowel Phoneme']

    X_test = test_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_female['Vowel Phoneme']

    # Creates the k-NN classifier with k=3 and Euclidean distance metric
    knn = KNeighborsClassifier(n_neighbors=3, metric='euclidean')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_female['Vowel Phoneme']

    X_test = test_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_female['Vowel Phoneme']

    # Creates the k-NN classifier with k=5 and Euclidean distance metric
    knn = KNeighborsClassifier(n_neighbors=5, metric='euclidean')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_female['Vowel Phoneme']

    X_test = test_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_female['Vowel Phoneme']

    # Creates the k-NN classifier with k=7 and Euclidean distance metric
    knn = KNeighborsClassifier(n_neighbors=7, metric='euclidean')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

"""# Female data, Manhattan distance, k = 1 to 7"""

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_female['Vowel Phoneme']

    X_test = test_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_female['Vowel Phoneme']

    # Creates the k-NN classifier with k=1 and Manhattan distance metric
    knn = KNeighborsClassifier(n_neighbors=1, metric='manhattan')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_female['Vowel Phoneme']

    X_test = test_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_female['Vowel Phoneme']

    # Creates the k-NN classifier with k=3 and Manhattan distance metric
    knn = KNeighborsClassifier(n_neighbors=3, metric='manhattan')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_female['Vowel Phoneme']

    X_test = test_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_female['Vowel Phoneme']

    # Creates the k-NN classifier with k=5 and Manhattan distance metric
    knn = KNeighborsClassifier(n_neighbors=5, metric='manhattan')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")

# Splits data with different random states
def split_data(df, random_state):
    train, test = train_test_split(df, test_size=0.25, stratify=df['Vowel Phoneme'], random_state=random_state)
    return train, test

# Runs the experiment five times
num_runs = 5

# Initializes lists to store F1 scores and confusion matrices
f1_scores = []
conf_matrices = []

# Runs the experiment five times with different train/test splits
for run in range(num_runs):

    # Generates a different random state for each run
    random_state = run

    # Splits female data
    train_female, test_female = split_data(df_female, random_state)

    # Separates features (formants) and labels (vowel phonemes)
    X_train = train_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_train = train_female['Vowel Phoneme']

    X_test = test_female[['Formant 1', 'Formant 2', 'Formant 3']]
    y_test = test_female['Vowel Phoneme']

    # Creates the k-NN classifier with k=7 and Manhattan distance metric
    knn = KNeighborsClassifier(n_neighbors=7, metric='manhattan')

    # Trains the classifier
    knn.fit(X_train, y_train)

    # Predicts vowel phonemes using the feature test set
    y_pred = knn.predict(X_test)

    # Calculates F1 score and appends to list of scores
    f1 = f1_score(y_test, y_pred, average='weighted')
    f1_scores.append(f1)

    # Calculates confusion matrix and appends to list of matrices
    conf_matrix = confusion_matrix(y_test, y_pred, labels=['IY', 'UW', 'AE'])
    conf_matrices.append(conf_matrix)

    print(f"\nRun {run + 1}:")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")

# Plots the confusion matrices
for i, conf_matrix in enumerate(conf_matrices):
  plt.figure(figsize=(8, 6))
  sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['IY', 'UW', 'AE'], yticklabels=['IY', 'UW', 'AE'])
  plt.xlabel('Predicted')
  plt.ylabel('True')
  plt.title(f'Confusion Matrix (Run {i+1})')
  plt.show()

# Calculates average F1 score
average_f1_score = np.mean(f1_scores)
print(f"Average F1 Score over {num_runs} runs: {average_f1_score:.2f}")